# -*- coding: utf-8 -*-
"""Mask_detection.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1TIJizxN7mJkP3_AtUgFynC1WMVjq9-uR
"""

import pandas as pd
import numpy as np
import os
import glob
from datetime import datetime
import xml.etree.ElementTree as ET 
import cv2
import matplotlib.pyplot as plt
import seaborn as sns
import warnings

warnings.filterwarnings('ignore')

"""Dataset setup/transformation"""

from google.colab import drive
# drive_path = "/content/drive/MyDrive/ECGR 4106/4106 Final Proj"
drive.mount('/content/drive')
drive_path = "/content/drive/MyDrive/4106FinalProj"

# set to false if all data has been transformed
TRANSFORM_DATA = False #@param ["True", "False"] {type:"raw"}

input_data = drive_path
annotations_path = drive_path + "/annotations"
images_path = drive_path + "/images"
output_data = drive_path + '/output'

dataset = {
            "file":[],
            "name":[],    
            "width":[],
            "height":[],
            "xmin":[],
            "ymin":[],   
            "xmax":[],
            "ymax":[],
           }

for anno in glob.glob(annotations_path+"/*.xml"):
    tree = ET.parse(anno)
    
    for elem in tree.iter():
        if 'size' in elem.tag:
            for attr in list(elem):
                if 'width' in attr.tag: 
                    width = int(round(float(attr.text)))
                if 'height' in attr.tag:
                    height = int(round(float(attr.text)))    

        if 'object' in elem.tag:
            for attr in list(elem):
                
                if 'name' in attr.tag:
                    name = attr.text                 
                    dataset['name']+=[name]
                    dataset['width']+=[width]
                    dataset['height']+=[height] 
                    dataset['file']+=[anno.split('/')[-1][0:-4]] 
                            
                if 'bndbox' in attr.tag:
                    for dim in list(attr):
                        if 'xmin' in dim.tag:
                            xmin = int(round(float(dim.text)))
                            dataset['xmin']+=[xmin]
                        if 'ymin' in dim.tag:
                            ymin = int(round(float(dim.text)))
                            dataset['ymin']+=[ymin]                                
                        if 'xmax' in dim.tag:
                            xmax = int(round(float(dim.text)))
                            dataset['xmax']+=[xmax]                                
                        if 'ymax' in dim.tag:
                            ymax = int(round(float(dim.text)))
                            dataset['ymax']+=[ymax]

df=pd.DataFrame(dataset)
df.head()

name_dict = {
    'with_mask': 0,
    'mask_weared_incorrect': 1,
    'without_mask': 2,
}

df['class'] = df['name'].map(name_dict)

fileNames = [*os.listdir(images_path)]
print('There are {} images in the dataset'.format(len(fileNames)))

from sklearn.model_selection import train_test_split
train, test = train_test_split(fileNames, test_size=0.1, random_state=42)
test, val = train_test_split(test, test_size=0.7, random_state=42)
print("Length of Train =",len(train))
print("Length of Valid =",len(val))
print("Length of test =", len(test))

sizeX = 256
sizeY = 256

if TRANSFORM_DATA:
  if not os.path.isdir(output_data + "/yolov4"):
    os.chdir(output_data )
    os.makedirs('./yolov4/data/train')
    os.makedirs('./yolov4/data/val')
    os.makedirs('./yolov4/data/test')
    os.makedirs('./yolov4/data/train/images')
    os.makedirs('./yolov4/data/train/labels')
    os.makedirs('./yolov4/data/test/images')
    os.makedirs('./yolov4/data/test/labels')
    os.makedirs('./yolov4/data/val/images')
    os.makedirs('./yolov4/data/val/labels')
  
  from PIL import Image

  def copyImages(imageList, folder_Name):
      for image in imageList:
          img = Image.open(input_data+"/images/"+image)
          img1 = img.resize((sizeX, sizeY))
          _ = img1.save(output_data+"/yolov4/data/"+folder_Name+"/images/"+image)

  copyImages(train, "train")
  copyImages(val, "val")
  copyImages(test, "test")

df['xmax'] = (sizeX/df['width'])*df['xmax']
df['ymax'] = (sizeY/df['height'])*df['ymax']
df['xmin'] = (sizeX/df['width'])*df['xmin']
df['ymin'] = (sizeY/df['height'])*df['ymin']

df[['xmax', 'ymax', 'xmin', 'ymin']] = df[['xmax', 'ymax', 'xmin', 'ymin']].astype('int64')

df['x_center'] = (df['xmax']+df['xmin']) / (2*sizeX)
df['y_center'] = (df['ymax']+df['ymin']) / (2*sizeY)
df['box_height'] = (df['xmax']-df['xmin']) / (sizeX)
df['box_width'] = (df['ymax']-df['ymin']) / (sizeY)

df = df.astype('string')
df.head()

if TRANSFORM_DATA:
  def create_labels(image_list, data_name):
      fileNames = [x.split(".")[0] for x in image_list]

      for name in fileNames:
          data = df[df.file==name]
          box_list = []
          
          for index in range(len(data)):
              row = data.iloc[index]
              box_list.append(row['class']+" "+row["x_center"]+" "+row["y_center"]\
                          +" "+row["box_height"]+" "+row["box_width"])
              
          text = "\n".join(box_list)
          with open(output_data+"/yolov4/data/"+data_name+"/labels/"+name+".txt", "w") as file:
              file.write(text)


  create_labels(train, "train")
  create_labels(val, "val")
  create_labels(test, "test")

"""YOLO v5

"""

# Commented out IPython magic to ensure Python compatibility.
# %cd /content/

!git clone https://github.com/ultralytics/yolov5
!pip install -qr /content/yolov5/requirements.txt

!pip install yolov5

from IPython.display import Image, clear_output
import torch
from yolov5 import utils
display = utils.notebook_init()

# Commented out IPython magic to ensure Python compatibility.
# configure .yaml file to guide the model for training
yaml_text = """train: /content/drive/MyDrive/4106FinalProj/output/yolov4/data/train/images
val: /content/drive/MyDrive/4106FinalProj/output/yolov4/data/train/images

nc: 3
names: ['with_mask', 'mask_weared_incorrect', 'without_mask']"""

with open("/content/yolov5/data/data.yaml", 'w') as file:
    file.write(yaml_text)

# %cat /content/yolov5/data/data.yaml

#customize iPython writefile so we can write variables
from IPython.core.magic import register_line_cell_magic

@register_line_cell_magic
def writetemplate(line, cell):
    with open(line, 'w') as f:
        f.write(cell.format(**globals()))

from google.colab import drive
drive.mount('/content/drive')

"""Hyper Parameters"""

# Commented out IPython magic to ensure Python compatibility.
# %%writetemplate /content/yolov5/models/hyp.yaml
# 
# optimizer: 'adam'
# lr0: 0.001  # initial learning rate (SGD=1E-2, Adam=1E-3) 
# lrf: 0.01  # final OneCycleLR learning rate (lr0 * lrf) 
# momentum: 0.937  # SGD momentum/Adam beta1 
# weight_decay: 0.0005  # optimizer weight decay 5e-4 
# warmup_epochs: 3.0  # warmup epochs (fractions ok) 
# warmup_momentum: 0.8  # warmup initial momentum 
# warmup_bias_lr: 0.1  # warmup initial bias lr 
# box: 0.05  # box loss gain 
# cls: 0.5  # cls loss gain 
# cls_pw: 1.0  # cls BCELoss positive_weight 
# obj: 1.0  # obj loss gain (scale with pixels) 
# obj_pw: 1.0  # obj BCELoss positive_weight 
# iou_t: 0.20  # IoU training threshold 
# anchor_t: 4.0  # anchor-multiple threshold 
# # anchors: 3  # anchors per output layer (0 to ignore) 
# fl_gamma: 0.0  # focal loss gamma (efficientDet default gamma=1.5) 
# hsv_h: 0.015  # image HSV-Hue augmentation (fraction) 
# hsv_s: 0.7  # image HSV-Saturation augmentation (fraction) 
# hsv_v: 0.4  # image HSV-Value augmentation (fraction) 
# degrees: 15.0 # image rotation (+/- deg) 
# translate: 0.1  # image translation (+/- fraction) 
# scale: 0.5  # image scale (+/- gain) 
# shear: 0.0  # image shear (+/- deg) 
# perspective: 0.0  # image perspective (+/- fraction), range 0-0.001 
# flipud: 0.0  # image flip up-down (probability) 
# fliplr: 0.5  # image flip left-right (probability) 
# mosaic: 1.0  # image mosaic (probability) 
# mixup: 0.0  # image mixup (probability) 
# copy_paste: 0.0  # segment copy-paste (probability)

"""YOLO V5 Model"""

# Commented out IPython magic to ensure Python compatibility.
# %%writetemplate /content/yolov5/models/custom_yolov5s.yaml
# 
# # parameters
# nc: 3  # number of classes
# depth_multiple: 0.33  # model depth multiple
# width_multiple: 0.5  # layer channel multiple
# 
# # anchors
# anchors:
#   - [10,13, 16,30, 33,23]  # P3/8
#   - [30,61, 62,45, 59,119]  # P4/16
#   - [116,90, 156,198, 373,326]  # P5/32
# 
# # YOLOv5 backbone
# backbone:
#   # [from, number, module, args]
#   [[-1, 1, Conv, [64, 6, 2, 2]],  # 0-P1/2
#    [-1, 1, Conv, [128, 3, 2]],  # 1-P2/4
#    [-1, 3, C3, [128]],
#    [-1, 1, Conv, [256, 3, 2]],  # 3-P3/8
#    [-1, 6, C3, [256]],
#    [-1, 1, Conv, [512, 3, 2]],  # 5-P4/16
#    [-1, 9, C3, [512]],
#    [-1, 1, Conv, [1024, 3, 2]],  # 7-P5/32
#    [-1, 3, C3, [1024]],
#    [-1, 1, SPPF, [1024, 5]],  # 9
#   ]
# 
# # YOLOv5 v6.0 head
# head:
#   [[-1, 1, Conv, [512, 1, 1]],
#    [-1, 1, nn.Upsample, [None, 2, 'nearest']],
#    [[-1, 6], 1, Concat, [1]],  # cat backbone P4
#    [-1, 3, C3, [512, False]],  # 13
# 
#    [-1, 1, Conv, [256, 1, 1]],
#    [-1, 1, nn.Upsample, [None, 2, 'nearest']],
#    [[-1, 4], 1, Concat, [1]],  # cat backbone P3
#    [-1, 3, C3, [256, False]],  # 17 (P3/8-small)
# 
#    [-1, 1, Conv, [256, 3, 2]],
#    [[-1, 14], 1, Concat, [1]],  # cat head P4
#    [-1, 3, C3, [512, False]],  # 20 (P4/16-medium)
# 
#    [-1, 1, Conv, [512, 3, 2]],
#    [[-1, 10], 1, Concat, [1]],  # cat head P5
#    [-1, 3, C3, [1024, False]],  # 23 (P5/32-large)
# 
#    [[17, 20, 23], 1, Detect, [nc, anchors]],  # Detect(P3, P4, P5)
#   ]

"""YOLO V3 Model"""

# %%writetemplate /content/yolov5/models/custom_yolov5s.yaml

# # Parameters
# nc: 3  # number of classes
# depth_multiple: 0.33  # model depth multiple
# width_multiple: 0.5  # layer channel multiple
# anchors:
#   - [10,13, 16,30, 33,23]  # P3/8
#   - [30,61, 62,45, 59,119]  # P4/16
#   - [116,90, 156,198, 373,326]  # P5/32

# # darknet53 backbone
# backbone:
#   # [from, number, module, args]
#   [[-1, 1, Conv, [32, 3, 1]],  # 0
#    [-1, 1, Conv, [64, 3, 2]],  # 1-P1/2
#    [-1, 1, Bottleneck, [64]],
#    [-1, 1, Conv, [128, 3, 2]],  # 3-P2/4
#    [-1, 2, Bottleneck, [128]],
#    [-1, 1, Conv, [256, 3, 2]],  # 5-P3/8
#    [-1, 8, Bottleneck, [256]],
#    [-1, 1, Conv, [512, 3, 2]],  # 7-P4/16
#    [-1, 8, Bottleneck, [512]],
#    [-1, 1, Conv, [1024, 3, 2]],  # 9-P5/32
#    [-1, 4, Bottleneck, [1024]],  # 10
#   ]

# # YOLOv3 head
# head:
#   [[-1, 1, Bottleneck, [1024, False]],
#    [-1, 1, Conv, [512, 1, 1]],
#    [-1, 1, Conv, [1024, 3, 1]],
#    [-1, 1, Conv, [512, 1, 1]],
#    [-1, 1, Conv, [1024, 3, 1]],  # 15 (P5/32-large)

#    [-2, 1, Conv, [256, 1, 1]],
#    [-1, 1, nn.Upsample, [None, 2, 'nearest']],
#    [[-1, 8], 1, Concat, [1]],  # cat backbone P4
#    [-1, 1, Bottleneck, [512, False]],
#    [-1, 1, Bottleneck, [512, False]],
#    [-1, 1, Conv, [256, 1, 1]],
#    [-1, 1, Conv, [512, 3, 1]],  # 22 (P4/16-medium)

#    [-2, 1, Conv, [128, 1, 1]],
#    [-1, 1, nn.Upsample, [None, 2, 'nearest']],
#    [[-1, 6], 1, Concat, [1]],  # cat backbone P3
#    [-1, 1, Bottleneck, [256, False]],
#    [-1, 2, Bottleneck, [256, False]],  # 27 (P3/8-small)

#    [[27, 22, 15], 1, Detect, [nc, anchors]],   # Detect(P3, P4, P5)
#   ]

start = datetime.now()
!python /content/yolov5/train.py --img 256 --batch 32 --epochs 200 --data /content/yolov5/data/data.yaml --cfg /content/yolov5/models/custom_yolov5s.yaml --hyp /content/yolov5/models/hyp.yaml --name yolov5s_results  --cache
end = datetime.now()

print("Runtime =",end-start)

!python /content/yolov5/detect.py --source /content/drive/MyDrive/4106FinalProj/output/yolov4/data/test/images/ --weight /content/yolov5/runs/train/yolov5s_results4/weights/best.pt --name expTestImage --imgsz 256 --conf 0.4  --line-thickness 1

color_dict = {
    'with_mask': (255, 0, 0),
    'mask_weared_incorrect':  (0, 255, 0),
    'without_mask': (0, 0, 255) 
}

def show_image(img_id):
    df_image = df[df.file==img_id]
    df_image[['xmin', 'ymin', 'xmax', 'ymax']] = df_image[['xmin', 'ymin', 'xmax', 'ymax']].astype('int64')
    path = output_data + '/yolov4/data/test/images/'+img_id# +'.png'
    img = plt.imread(path)

    imge = img.copy()

    for index in range(len(df_image)):
        row = df_image.iloc[index]
        cv2.rectangle(imge, 
                      (row['xmin'], row['ymin']),
                      (row['xmax'], row['ymax']),
                      color=color_dict[row['name']],
                      thickness=1)

    img_pred = plt.imread('/content/yolov5/runs/detect/expTestImage5/'+img_id)
    # ===================================
    plt.figure(figsize=(14,17))

    plt.subplot(1,2,1)
    plt.imshow(imge)
    plt.axis('off')
    plt.title('Image with Truth Box')

    plt.subplot(1,2,2)
    plt.imshow(img_pred)
    plt.axis('off')
    plt.title('Image with Predicted Box')

import os, random
show_image(random.choice(os.listdir(output_data + "/yolov4/data/test/images/"))) 
show_image(random.choice(os.listdir(output_data + "/yolov4/data/test/images/"))) 
plt.show()

"""Video Detection"""

!python /content/yolov5/detect.py --source /content/drive/MyDrive/4106FinalProj/vid0.mp4 --weight /content/yolov5/runs/train/yolov5s_results4/weights/best.pt --name expTestImage --imgsz 256 --conf 0.4  --line-thickness 1

"""Download Model"""

!zip -r /content/file.zip /content/yolov5/runs/

from google.colab import files
files.download("/content/file.zip")